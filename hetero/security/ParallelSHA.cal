
namespace hetero.security.sha:
  import var system.io.println_s_i;
  actor IntToCharCast() uint In ==> uint(size = 8) Out:
    action In:[t] ==> Out:[(t::uint(size = 8))]
    do 
      println_s_i("casting: ", t);  
    end
  end
    
  actor StreamDispatcher()
    uint(size = 8) stringStream
    ==>
    
        uint(size = 8) stream0, 
      
        uint(size = 8) stream1
      :

    uint(size = 32) counter := 0;

    
    readSize0: action stringStream:[b] repeat 4 ==> stream0:[b] repeat 4
    do
      counter := bytesToWord(b);
    end    
    
    emitStream0: action stringStream:[ch] ==> stream0:[ch]
    guard counter > 0
    do
      counter := counter - 1;
    end
    
    readSize1: action stringStream:[b] repeat 4 ==> stream1:[b] repeat 4
    do
      counter := bytesToWord(b);
    end    
    
    emitStream1: action stringStream:[ch] ==> stream1:[ch]
    guard counter > 0
    do
      counter := counter - 1;
    end
    

    
    schedule fsm init:
      init(readSize0) --> s0;
    
      s0 (emitStream0) --> s0;
      s0 (readSize1) --> s1;
      
      s1 (emitStream1) --> s1;
      s1 (readSize0) --> s0;
      
    end
    

    
    priority
    
      emitStream0 > readSize1;
      
      emitStream1 > readSize0;
      
    end
    
  end
    
    

  actor HashCollector()
    
        uint(size = 32) stream0, 
      
        uint(size = 32) stream1
      
    ==>
    uint(size = 32) hashStream:

    uint(size = 32) counter := 0;
    uint HASH_STREAM_SIZE = 5;

    
    stop: action ==>
    guard counter = HASH_STREAM_SIZE
    do
      counter := 0;
    end
    
      collectStream0: action stream0:[h] ==> hashStream:[h]
      do
        counter := counter + 1;
      end
      
      collectStream1: action stream1:[h] ==> hashStream:[h]
      do
        counter := counter + 1;
      end
      

    
    schedule fsm s0:
    
      s0(collectStream0) --> s0;
      s0(stop) --> s1;
      
      s1(collectStream1) --> s1;
      s1(stop) --> s0;
      
    end
    

    
    priority
    
      stop > collectStream0;   
      
      stop > collectStream1;   
      
    end
    
  end
  
    
  network ParallelSHA() uint strings ==> uint hashes:

    entities
      cast = IntToCharCast();

      dispatcher = StreamDispatcher();

      collector = HashCollector();

      // processing elements
      
      pe0 = SHA1();
      
      pe1 = SHA1();
      
    
    structure

      strings --> cast.In;
      cast.Out -->dispatcher.stringStream;
      
      dispatcher.stream0 --> pe0.text;
      pe0.hash --> collector.stream0;
      
      dispatcher.stream1 --> pe1.text;
      pe1.hash --> collector.stream1;
      
      collector.hashStream --> hashes;
  end
  
end
    
