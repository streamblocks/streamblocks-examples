
import StreamDispatcher
import HashCollector

class ParallelSHA():


  def __init__(self, num_pes, strings_per_pe, min_size, max_size):
    self.size = num_pes
    self.strings_per_pe = strings_per_pe
    self.min_size = min_size
    self.max_size = max_size

  def getPEInstances(self):

    pes = ""
    for ix in range(0, self.size):
      pes += """
      pe{index} = SHA1();
      """.format(index = ix)
    return pes
  

  def getConnections(self):

    connections = ""

    for ix in range(0, self.size):

      connections += """
      dispatcher.stream{index} --> pe{index}.text;
      pe{index}.hash --> collector.stream{index};
      """.format(index = ix)
    return connections
  
  def getNetwork(self):

    actor = """
  network ParallelSHA() uint strings ==> uint hashes:

    entities

      dispatcher = StreamDispatcher();

      collector = HashCollector();

      // processing elements
      {peInstances}
    
    structure

      strings --> dispatcher.stringStream {{bufferSize={buff_size};}};
     
      {connections}
      collector.hashStream --> hashes;
  end
  """.format(peInstances = self.getPEInstances(), 
    connections = self.getConnections(),
    buff_size = self.max_size * self.size)
    return actor

  def getActors(self):
    
    return """
namespace hetero.security.sha:
  import entity ART.art_Sink_txt; 
  actor IntToCharCast() uint In ==> uint(size = 8) Out:
    action In:[t] ==> Out:[(t::uint(size = 8))]
    end
  end
    {dispatcher}
    {collector}
    {network}
  
  network SHANetwork() ==>:

    entities
      
      source = RandomCharacters(count={num_strings}, min_size={min_size}, max_size={max_size});

      // the following actor is generated by the python scripts
      shaEngines = ParallelSHA() {{partition = \"hw\";}}; 

      sink = Sink();


    structure

      source.rand --> shaEngines.strings;
      shaEngines.hashes --> sink.In;

  end
end
    """.format(
      dispatcher = StreamDispatcher.getStreamDispatcher(self.size),
      collector = HashCollector.getHashCollector(self.size),
      network = self.getNetwork(),
      num_strings=self.strings_per_pe * self.size,
      min_size=self.min_size - 4,
      max_size=self.max_size - 4)


if __name__ == "__main__":

  import argparse

  parser = argparse.ArgumentParser(description="Generate a parallel SHA1 network")
  parser.add_argument('--num-pes', type=int, help="number of SHA1 processing elements", required=True)
  parser.add_argument('--min-size', type=int, help="Minimum string size", required=True)
  parser.add_argument('--max-size', type=int, help='maximum string size', required=True)
  parser.add_argument('--strings-per-pe', type=int, help='number of strings per pe', required=True)
  
  args = parser.parse_args()
  print(ParallelSHA(args.num_pes, args.strings_per_pe, args.min_size, args.max_size).getActors())