namespace hetero.stencil.kernels.Blur:

  import entity hetero.stencil.kernels.utils.KernelStreamer;
  import entity hetero.stencil.kernels.utils.StreamIterator;
  import entity hetero.stencil.kernels.utils.AlphaFilter;
  import entity hetero.stencil.kernels.utils.DynamicFilter;
  import entity hetero.stencil.kernels.utils.Splitter;
  import entity hetero.stencil.bitmap.streamers.BitMapSimpleStreamer;
  import entity hetero.stencil.bitmap.encoders.SimpleBitmapEncoder;


  import entity ART.art_Sink_bin;
  import entity ART.art_Source_byte;


  @pipeline(flushing=true, ii=1)
  actor BlurCompute(type DTYPE) 
    DTYPE Ref_p0_p1, // Ref(x = 0, y = 1)
    DTYPE Ref_p1_p0, // Ref(x = 1, y = 0)
    DTYPE Ref_p0_p0, // Ref(x = 0, y = 0)
    DTYPE Ref_n1_p0, // Ref(x = -1, y = 0)
    DTYPE Ref_p0_n1 // Ref(x = 0, y = -1)
    ==> DTYPE Out:

    compute:action 
      Ref_p0_p1:[t0],
      Ref_p1_p0:[t1],
      Ref_p0_p0:[t2],
      Ref_n1_p0:[t3],
      Ref_p0_n1:[t4] ==>
      Out:[
        (t0 + t1 + t2 + t3 + t4) / 5
      ]
    end
  end



  
  network BlurKernel() 
    uint(size=8) In,
    uint Width, uint Height ==> uint(size=8) Out:
  
    var 
      int X_UB = -2;
      int Y_UB = -2;
      int X_LB = 1;
      int Y_LB = 1;
    entities

      f0 = DynamicFilter(
        DTYPE: uint(size=8),
        x_lb_offset = X_LB, 
        x_ub_offset = X_UB,
        y_lb_offset = Y_LB,
        y_ub_offset = Y_UB,
        x_offset = 0,
        y_offset = 1);
      f1 = DynamicFilter(
        DTYPE: uint(size=8),
        x_lb_offset = X_LB, 
        x_ub_offset = X_UB,
        y_lb_offset = Y_LB,
        y_ub_offset = Y_UB,
        x_offset = 1,
        y_offset = 0);
      f2 = DynamicFilter(
        DTYPE: uint(size=8),
        x_lb_offset = X_LB, 
        x_ub_offset = X_UB,
        y_lb_offset = Y_LB,
        y_ub_offset = Y_UB,
        x_offset = 0,
        y_offset = 0);
      f3 = DynamicFilter(
        DTYPE: uint(size=8),
        x_lb_offset = X_LB, 
        x_ub_offset = X_UB,
        y_lb_offset = Y_LB,
        y_ub_offset = Y_UB,
        x_offset = -1,
        y_offset = 0);
      f4 = DynamicFilter(
        DTYPE: uint(size=8),
        x_lb_offset = X_LB, 
        x_ub_offset = X_UB,
        y_lb_offset = Y_LB,
        y_ub_offset = Y_UB,
        x_offset = 0,
        y_offset = -1);

      s0 = Splitter(DTYPE: uint(size=8));
      s1 = Splitter(DTYPE: uint(size=8));
      s2 = Splitter(DTYPE: uint(size=8));
      s3 = Splitter(DTYPE: uint(size=8));

      compute = BlurCompute(DTYPE: uint(size=8));


    structure

      Width --> f0.Width; 
      Height --> f0.Height; 
      Width --> f1.Width; 
      Height --> f1.Height; 
      Width --> f2.Width; 
      Height --> f2.Height; 
      Width --> f3.Width; 
      Height --> f3.Height; 
      Width --> f4.Width; 
      Height --> f4.Height; 


      In --> s0.In;
      
      s0.Left --> f0.In;
      s0.Right --> s1.In;
      
      s1.Left --> f1.In;
      s1.Right --> s2.In;

      s2.Left --> f2.In;
      s2.Right --> s3.In;

      s3.Left --> f3.In;
      s3.Right --> f4.In;

      f0.Out --> compute.Ref_p0_p1;
      f1.Out --> compute.Ref_p1_p0;
      f2.Out --> compute.Ref_p0_p0;
      f3.Out --> compute.Ref_n1_p0;
      f4.Out --> compute.Ref_p0_n1;

      compute.Out --> Out;

  end


  network BlurNetworkSingle() 
    uint(size = 8) PixelStream,
    uint(size = 32) Width,
    uint(size = 32) Height ==>
    uint(size = 8) Out:

    entities

      /**Pad the borders of the image so that the output image
       will have the same size as the input image
       */
      padding = KernelStreamer(
        stencil_x_neg = -1, stencil_x_pos = 1,
        stencil_y_neg = -1, stencil_y_pos = 1,
        pad_value = 0
      );

      kernel = BlurKernel();


    structure

      PixelStream --> padding.PixelStream;
      Width --> padding.Width;
      Height --> padding.Height;

      padding.PaddedStream --> kernel.In;
      padding.PaddedHeight --> kernel.Height;
      padding.PaddedWidth --> kernel.Width;

      kernel.Out --> Out;

  end


  /**
  A soft iterative blur network, the NUM_ITERATION parameter specifies the number
  of blur filters applied to the  input PixelStream. The buffer size on
  the iterator.IteratedStream should be correctly sized to avoid deadlock
   */
  network BlurNetworkSingleIterative() 
    uint(size = 8) PixelStream,
    uint(size = 32) Width,
    uint(size = 32) Height ==>
    uint(size = 8) Out:

    entities


      iterator = StreamIterator(DTYPE : uint(size = 8), 
        NUM_ITERATIONS = 5);
      /**Pad the borders of the image so that the output image
       will have the same size as the input image
       */
      padding = KernelStreamer(
        stencil_x_neg = -1, stencil_x_pos = 1,
        stencil_y_neg = -1, stencil_y_pos = 1,
        pad_value = 0
      );

      kernel = BlurKernel();


    structure

      PixelStream --> iterator.InitialStream;
      Width --> iterator.WidthIn;
      Height --> iterator.HeightIn;

      iterator.WidthOut --> padding.Width;
      iterator.HeightOut --> padding.Height;
      iterator.PixelStream --> padding.PixelStream;

      
      padding.PaddedStream --> kernel.In;
      padding.PaddedHeight --> kernel.Height;
      padding.PaddedWidth --> kernel.Width;

      kernel.Out --> iterator.IteratedStream;

      iterator.Out --> Out;

  end

  

  network BlurLayeredNetworkSingle() 
    uint(size = 8) PixelStream,
    uint(size = 32) Width,
    uint(size = 32) Height ==>
    uint(size = 8) Out:

    entities

      layer_0 = BlurNetworkSingle();
      layer_1 = BlurNetworkSingle();
      layer_2 = BlurNetworkSingle();
      layer_3 = BlurNetworkSingle();
      
    structure

      PixelStream --> layer_0.PixelStream;
      layer_0.Out --> layer_1.PixelStream;
      layer_1.Out --> layer_2.PixelStream;
      layer_2.Out --> layer_3.PixelStream;
      layer_3.Out --> Out;

      Width --> layer_0.Width;
      Height --> layer_0.Height;
      Width --> layer_1.Width;
      Height --> layer_1.Height;
      Width --> layer_2.Width;
      Height --> layer_2.Height;
      Width --> layer_3.Width;
      Height --> layer_3.Height;
      

      

  end

end